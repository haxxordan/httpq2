#!/public/bin/perl

#
# This is the expected format for the documentation syntax.
#
# /*!
# <function>
#    <name></name>
#    <action></action>
#    <arguments>
#		<name></name>
#		<description></description>
#	 </arguments>
#    <return></return>
#    <example></example>
#    <test></test>
# </function>
# !*/
#

use Class::Struct;
use URI::Escape;
use Getopt::Std;
use URI::URL;
use XML::LibXML;


struct( FunctionTag => 
	{
		name => '$',
		action => '$',
		arguments => '@',
		return => '$',
		example => '$',
	}
);

struct( ArgumentTag => 
	{
		name => '$',
		description => '$',
	}
);


main();

sub main()
{
	my %opts=();
	getopts("f:o:", \%opts);

	die "usage: httpq_makedoc.pl -f <input_file> -o <output_file>\n" if !defined $opts{f};
	my $filename = $opts{f};

	@ftags = ();
	parsefile($filename, \@ftags);
	
	if (defined $opts{o})
	{
		writexml($opts{o}, @ftags);
	}
}

# @ftags = ();
# parsefile($filename, \@ftags);
sub parsefile()
{
	my $ftags = pop(@_);
	my $filename = pop(@_);

	open (FILE, $filename) or die "Failed to open $filename : $!";

	my $blob = 0;
	my $marker = 0;

	while (<FILE>) 
	{
		my $line = $_;
		chomp($line);

		if($line =~ /^\/\*\!/) # /*!
		{
			$marker = 1;
			$blob = "";
		}
		elsif($line =~ /^\!\*\//) # !*/
		{
			my $tag = parsexml($blob);
			if ($tag) {
				push(@{$ftags}, $tag);
			}
			$marker = 0;
		}
		elsif ($marker == 1)
		{
			$blob .= $line;
		}
	}
	close(FILE);

	@{$ftags} = sort {$a->name cmp $b->name} @{$ftags};
}

sub trim($)
{
	my $x = shift;
	$x =~ s/^\s+|\s+$//g;
	return $x;
}

sub parsexml()
{
	my $blob = pop(@_);
	
	my $tag = FunctionTag->new();
	my $parser = XML::LibXML->new();

	$doc = $parser->parse_string($blob);
	
	my @node = $doc->getElementsByTagName('name');
	$tag->name( trim($node[0]->getFirstChild->getData) );
	my @node = $doc->getElementsByTagName('action');
	$tag->action( trim($node[0]->getFirstChild->getData) );
	my @node = $doc->getElementsByTagName('return');
	$tag->return( trim($node[0]->getFirstChild->getData) );
	my @node = $doc->getElementsByTagName('example');
	$tag->example( trim($node[0]->getFirstChild->getData) );

	my @nodes = $doc->getElementsByTagName('arguments');
	foreach my $node (@nodes) 
	{
		my $arg = ArgumentTag->new();
		
		my @node = $node->getElementsByTagName('name');
		$arg->name( trim($node[0]->getFirstChild->getData) );
		my @node = $node->getElementsByTagName('description');
		$arg->description( trim($node[0]->getFirstChild->getData) );

		push(@{$tag->arguments}, $arg);
	}
	
	return $tag;
}

# /*!
# <function>
#    <name></name>
#    <action></action>
#    <arguments>
#		<name></name>
#		<description></description>
#	 </arguments>
#    <return></return>
#    <example></example>
# </function>
sub writexml()
{
	my ($file, @Tags) = @_;

    my $doc = XML::LibXML::Document->new("1.0", "UTF-8");
    
    my $now_string = localtime;
    my $comment = $doc->createComment( "generated by httpq_makedoc.pl on $now_string" );
    $doc->appendChild($comment);

	my $root = $doc->createElement('functions');
    $doc->setDocumentElement($root);
    
	foreach $tag (@Tags)
	{
		my $f = $doc->createElement('function');
		
		$f->appendTextChild('name', $tag->name );
		$f->appendTextChild('action', uri_escape($tag->action) );
		
		my $aa = $doc->createElement('arguments');
		foreach $arg (@{$tag->arguments})
		{
			my $a = $doc->createElement('argument');
			
			$a->appendTextChild('name', $arg->name);
			$a->appendTextChild('description', uri_escape($arg->description));
			
			$aa->appendChild($a);
		}
		$f->appendChild($aa);

		$f->appendTextChild('return', uri_escape($tag->return) );
		$f->appendTextChild('example', uri_escape($tag->example) );

		$root->appendChild($f);
	}		
    
	open(FILE, ">$file") or die "Failed to open $file : $!";
	print FILE $doc->serialize(1);
	close(FILE);
}
